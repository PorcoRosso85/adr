#!/usr/bin/env bash
set -euo pipefail

# Load common library functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib.sh"

PREV="${1:-adr/log.jsonl.preview}"
err(){ echo "[ERR] $*" >&2; exit 1; }

# Check for duplicate URIs before normalization
check_no_dups || exit 1

# Read allowed URIs from CUE (single source of truth)
ALLOWED_JSON=$(normalize_allowed) || err "failed to export AllowedURIs from CUE"

# 0) Basic checks
jq -s -e 'length > 0' "$PREV" >/dev/null || err "empty JSONL file"
jq -s -e 'all(.[]; .id != null and .uri != null)' "$PREV" >/dev/null || err "id or uri missing"

# ID uniqueness
jq -s -e '(map(.id)|length) == (map(.id)|unique|length)' "$PREV" >/dev/null || err "duplicate id found"

# AllowedURIs whitelist (deny-by-default with diff display)
UNAUTHORIZED=$(jq -s -r --argjson a "$ALLOWED_JSON" '
  [.[].uri] | unique | map(select(. as $u | ($a|index($u))==null))
' "$PREV")
if [ "$UNAUTHORIZED" != "[]" ]; then
  echo "[ERR] Unauthorized URIs detected (not in AllowedURIs):" >&2
  echo "$UNAUTHORIZED" | jq -r '.[]' >&2
  err "deny-by-default: unauthorized URIs found"
fi

# Accepted requires spec (PR-time requirement)
jq -s -e 'all(.[]; if .status=="Accepted" then (.spec!=null) else true end)' "$PREV" >/dev/null || err "Accepted Decision missing spec"

# alias_to rules: Deprecated must have alias_to, others must not
jq -s -e --argjson a "$ALLOWED_JSON" '
  all(.[]; if .status=="Deprecated" then (.alias_to!=null and ($a|index(.alias_to))!=null) else (.alias_to==null) end)
' "$PREV" >/dev/null || err "alias_to rule violation"

# alias_to: no cycles (URI redirect graph must be acyclic)
jq -s -e '
  def edges: [ .[] | select(.status=="Deprecated" and (.alias_to!=null)) | {f:.uri, t:.alias_to} ];
  def next($g; $n): [ $g[] | select(.f==$n) | .t ];
  def cyc($g; $start; $n; $seen):
    if ($seen|index($n)) then false
    else any(next($g; $n)[]?; if .==$start then true else cyc($g; $start; .; ($seen+[$n])) end)
    end;
  (edges) as $g
  | if ($g|length)==0 then true else
      all( ([$g[]|.f] | unique[])[]; (cyc($g; .; .; [])) | not )
    end
' "$PREV" >/dev/null || err "alias_to contains cycle"

# 1) supersedes checks: existence, same-URI, DAG
# Helper: normalize supersedes to array
jq -s -e '
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  . as $all
  | [($all[] | .id)] as $ids
  | all($all[]; (arr(.supersedes) | all(. as $sid | $ids | index($sid) != null)))
' "$PREV" >/dev/null || err "supersedes references unknown ID"

# Same-URI constraint
jq -s -e '
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  . as $all
  | (map({(.id):.uri})|add) as $id2uri
  | all($all[]; (arr(.supersedes) | all(. as $sid | $id2uri[$sid] == .uri )))
' "$PREV" >/dev/null || err "supersedes points to different URI"

# DAG check (no cycles)
jq -s -e '
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  . as $all
  | (map({(.id): {uri:.uri, sup: arr(.supersedes)}}) | add) as $m
  | def dfs($start; $n; $seen):
      if ($seen|index($n)) then true
      else
        (($m[$n].sup // []) | length) as $k
        | if $k==0 then false
          else any(($m[$n].sup // [])[]; if .==$start then true else dfs($start; .; ($seen+[$n])) end)
          end
      end;
  any(keys[] as $id | dfs($id; $id; [])) | not
' "$PREV" >/dev/null || err "supersedes contains cycle"

# 2) Current uniqueness: only one Accepted per URI (excluding superseded)
jq -s -e '
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  ( [ .[] | arr(.supersedes) ] | flatten | unique ) as $sup
  | [ .[] | select(.status=="Accepted") | select((.id | IN($sup[])) | not) ]
  | group_by(.uri) | all(.[]; length<=1)
' "$PREV" >/dev/null || err "multiple current Accepted Decisions for same URI"

# 3) Compatibility: key inclusion (old âŠ† new)
REM=$(mktemp)
jq -s -r '
  def pathsS: paths(scalars) | map(tostring) | join(".");
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  . as $all
  | (map({(.id): .})|add) as $byId
  | [ $all[] | select(.supersedes!=null) ][]
  | . as $n
  | (arr(.supersedes)[]) as $oid
  | select($byId[$oid].uri == .uri)
  | ($byId[$oid].spec // {}) as $old
  | (.spec // {}) as $new
  | (($old|pathsS) - ($new|pathsS)) as $removed
  | if ($removed|length)>0
    then "BREAK \(.uri) old=\($oid) -> new=\(.id) removed=" + ($removed|join(","))
    else empty end
' -c "$PREV" > "$REM"
[ ! -s "$REM" ] || { cat "$REM" >&2; err "breaking change detected (key removal/narrowing)"; }

# 4) Compatibility: old valid examples pass new spec (if examples exist)
LIST=$(mktemp)
jq -s -r '
  def arr(x): if (x|type)=="array" then x elif (x|type)=="string" then [x] else [] end;
  . as $all | (map({(.id): .})|add) as $byId
  | [ $all[] | select(.supersedes!=null) ][]
  | . as $n
  | (arr(.supersedes)[]) as $oid
  | select($byId[$oid].uri == .uri)
  | "\(.id) \($oid) \(.uri)"
' "$PREV" > "$LIST"

fail=0
while read -r NEW OLD URI; do
  SPEC_JSON=$(jq -s -c --arg id "$NEW" 'map(select(.id==$id)) | .[0].spec' "$PREV")
  [ "$SPEC_JSON" != "null" ] || { echo "[WARN] spec missing for $NEW" >&2; continue; }

  if [ -d "adr/examples/$OLD/valid" ]; then
    tmp=$(mktemp)
    printf 'package x\nspec: %s\n' "$SPEC_JSON" > "$tmp"
    for f in adr/examples/"$OLD"/valid/*.json; do
      [ -e "$f" ] || continue
      cue vet -c -e spec "$tmp" "$f" >/dev/null 2>&1 || {
        echo "[ERR] example validation failed: $URI $OLD -> $NEW ($f)" >&2
        fail=1
      }
    done
    rm -f "$tmp"
  fi
done < "$LIST"
[ $fail -eq 0 ] || err "old valid examples incompatible with new spec"

echo "[OK] all checks passed"
